import Foundation

/*
 * Rather than passing in an "attenuation" vector and a "scattered" ray,
 * we return them as an optional tuple. This optional also effectively
 * replaces the need for the function to have a return type of Bool.
 *
 * Note that the performance of caching "attenuation" and "scattered" and then
 * passing them by reference for later modification is indistinguisable from
 * the performance of returning those values (generated by the function) in a tuple.
 *
 * Finally, the choice of the word "materialType" over "material" allows us to have
 * instance variables named "material" with type "materialType", as Swift will not allow
 *      `let material: material`
 */
class materialType {
    
    func scatter(rayIn: ray, record: hitRecord) -> (vec3, ray)? {
        return nil
    }
}

final class lambertian: materialType {
    
    final let albedo: vec3
    
    init(albedo: vec3) {
        self.albedo = albedo
    }
    
    convenience init(_ x: Float, _ y: Float, _ z: Float) {
        self.init(albedo: vec3(x, y, z))
    }
    
    final override func scatter(rayIn: ray, record: hitRecord) -> (vec3, ray)? {
        
        let target = record.p + record.normal + randomInUnitSphere()
        let scattered = ray(record.p, target - record.p)
        
        return (albedo, scattered)
    }
}

/*
 * For metal, I elect to use the term "specular" here in place of "albedo",
 * following suit of recent discussions/resources on physically based shading.
 * Similarly, I elect to use "roughness" in place of "fuzz".
 */

final class metal: materialType {
    
    final let specular: vec3
    final let roughness: Float
    
    init(specular: vec3, roughness: Float) {
        self.specular = specular
        self.roughness = roughness
    }
    
    convenience init(_ x: Float, _ y: Float, _ z: Float, roughness: Float) {
        self.init(specular: vec3(x, y, z), roughness: roughness)
    }
    
    final override func scatter(rayIn: ray, record: hitRecord) -> (vec3, ray)? {
        
        let reflected = reflection(rayIn.direction.unitVector(), record.normal)
        let scattered = ray(record.p, reflected + roughness * randomInUnitSphere())
        
        if dot(scattered.direction, record.normal) > 0 {
            return (specular, scattered)
        } else {
            return nil
        }
    }
}

final class dielectric: materialType {
    
    final let ior: Float // Index of refraction, equivalent to the author's "ref_idx".
    
    init(ior: Float) {
        self.ior = ior
    }
    
    final override func scatter(rayIn: ray, record: hitRecord) -> (vec3, ray)? {
        
        var outwardNormal: vec3
        let reflected = reflection(rayIn.direction, record.normal)
        let attenuation = vec3(1, 1, 1)
        
        // Index of refraction of incident and transmitted media
        var iorI: Float
        var iorT: Float
        
        let iDotN = dot(rayIn.direction, record.normal)
        
        if iDotN > 0 {
            outwardNormal = -record.normal
            iorI = ior
            iorT = 1.0
        } else {
            outwardNormal = record.normal
            iorI = 1.0
            iorT = ior
        }
        
        if let refracted = refract(rayIn.direction, outwardNormal, iorI / iorT) {
            
            return (attenuation, ray(record.p, refracted))
            
        } else {
            // See the author's comments on the return value of false here.
            // While we can't simultaneously return false in our case (which is a nil tuple),
            // we don't need to because later code will never return false.
            return (attenuation, ray(record.p, reflected))
        }
    }
}