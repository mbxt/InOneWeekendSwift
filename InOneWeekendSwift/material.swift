import Foundation

/*
 * Rather than passing in an "attenuation" vector and a "scattered" ray,
 * we return them as an optional tuple. This optional also effectively
 * replaces the need for the function to have a return type of Bool.
 *
 * Note that the performance of caching "attenuation" and "scattered" and then
 * passing them by reference for later modification is indistinguisable from
 * the performance of returning those values (generated by the function) in a tuple.
 *
 * Finally, the choice of the word "materialType" over "material" allows us to have
 * instance variables named "material" with type "materialType", as Swift will not allow
 *      `let material: material`
 */
class materialType {
    
    func scatter(rayIn: ray, record: hitRecord) -> (vec3, ray)? {
        return nil
    }
}

final class lambertian: materialType {
    
    final let albedo: vec3
    
    init(albedo: vec3) {
        self.albedo = albedo
    }
    
    convenience init(_ x: Float, _ y: Float, _ z: Float) {
        self.init(albedo: vec3(x, y, z))
    }
    
    final override func scatter(rayIn: ray, record: hitRecord) -> (vec3, ray)? {
        
        let target = record.p + record.normal + randomInUnitSphere()
        let scattered = ray(record.p, target - record.p)
        
        return (albedo, scattered)
    }
}